#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_control_flow_attributes : require

#include "lib/Common.h"
#include "lib/MonteCarlo.h"
#include "lib/BRDF.h"
#include "lib/RandomSequence.h"
#include "lib/CameraCommon.h"
#include "lib/LightSampling.h"
#include "lib/Material.h"

layout(location = 0) rayPayloadEXT RayPayloadInfo rayInfo;

void main() 
{     
    uvec2 bufferSize = uvec2(uint(globalParam.viewSize.x), uint(globalParam.viewSize.y));
	uint linearIndex = gl_LaunchIDEXT.x + (gl_LaunchIDEXT.y * bufferSize.x); 

    RandomSequence randSequence;
	RandomSequenceInitialize(randSequence, linearIndex, uint(globalParam.samplingData.x));

    uint rayCounter  = 0;
	uint sampleIndex = 0;
	uint sampleCount = 1;
	vec3 pixelColor  = vec3(0, 0, 0);

    for(uint i = 0 ; i < sampleCount ; ++i)
    {
        vec3 irradiance = vec3(0.0,0.0,0.0);

        // camera info
		CameraInfo camera;
		camera.pos = globalParam.pos;
		camera.invProj = globalParam.invProj;
		camera.invView = globalParam.invView;
		camera.viewSize = globalParam.viewSize;

        // sample ray
		RayDesc ray;
		uvec2 pixel;
		float emitterPdf;
		SampleEmitter(camera, gl_LaunchIDEXT.xy, randSequence, sampleIndex, 0, 0, ray, pixel, emitterPdf);
		if (emitterPdf <= 0.0) 
        {
			continue;
		}

        RayCone rayCone;
		rayCone.spreadAngle = globalParam.samplingData.y;

        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 1, 0, ray.origin /* position == vec3(0.0001,0,0) will lead to crash*/, ray.tMin, ray.direction, ray.tMax, 0); 
        rayCounter += 1;

        // throughput
		vec3 rayThroughput = vec3(1.0, 1.0, 1.0);
		float materialPdf  = 0.0;

        // bounces
		uint maxBounces = 8;

        for(uint bounces = 0 ; bounces < maxBounces; bounces++)
        {
            if(rayInfo.hitT < 0)
            {
                int skyLightId = 0;
                vec3 radiance = vec3(0.0,0.0,0.0);
                SkyLightEvalLight(skyLightId,ray.direction,ray,radiance);

                float misWeight = 1.0;

                if(bounces > 0)
                {
                    float lightPdf = 0.0;
                    vec3 lightUV = GetLightUV(skyLightId,ray,rayInfo);
                    PdfLight(ray,rayInfo,skyLightId,lightUV,lightPdf);

                    misWeight = PowerHeuristic(materialPdf, lightPdf);
                }

                irradiance += radiance * rayThroughput * misWeight;
                break;
            }

            vec3 emission = rayInfo.radiance;
            if(length(emission) > 0.0)
            {
                irradiance += emission * rayThroughput;
                break;
            }

            bounces += 1;

            ray.origin = ray.origin + ray.direction * rayInfo.hitT;
			RayPayloadInfo rayHitInfo = rayInfo;

            if(true)
            {
                vec4 randSample = RandomSequenceGenerateSample4D(randSequence, sampleIndex);

				// sample light
				int lightId;
				vec3 lightUV;
				float lightPdf;
				SampleLight(ray, rayHitInfo, randSample, lightId, lightUV, lightPdf);

                // shadow test
				if (lightPdf > 0.0)
				{
					RayDesc lightRay;
					RayCone lightRayCone = rayCone;

					// light Ray
					GenerateLightRay(ray, lightId, lightUV, lightRay);

                    // self intersection
                    const float minBias = 0.01f;
                    const float maxBias = max(minBias,globalParam.samplingData.w);
                    const float normalBias = mix(maxBias,minBias,clamp(dot(rayInfo.worldNormal,lightRay.direction),0.0,1.0));
                    lightRay.origin += rayInfo.worldNormal * normalBias;
					
					// trace LightRay
					traceRayEXT(topLevelAS, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, 0, 0, 0, lightRay.origin, lightRay.tMin, lightRay.direction, lightRay.tMax, 0);
					rayCounter++;

                    //no occluder to light
					if (rayInfo.hitT < 0)
					{
						vec3 radiance;
						EvalLight(lightId, lightUV, lightRay, radiance);
						
						// Evaluate material
						vec3 F;
						float bsdfPdf = 0.0;
						EvalMaterial(ray.direction, lightRay.direction, rayHitInfo, F, bsdfPdf);

						// mis weight
						irradiance += rayThroughput * PowerHeuristic(lightPdf, bsdfPdf) * F * abs(dot(rayHitInfo.worldNormal, lightRay.direction)) * radiance / lightPdf;
					}
				}
            }

            // trace bounce ray
            vec3 direction;
            vec3 throughput;
            vec3 randSample = RandomSequenceGenerateSample3D(randSequence, sampleIndex);
            float signedPositionBias;
            SampleMaterial(ray.direction, rayHitInfo, randSample, direction, throughput, materialPdf, signedPositionBias);
            if (materialPdf == 0.0) 
            {
                break;
            }

            // throughput
            rayThroughput *= throughput;

            // Update ray
            ray.direction = direction;
            const float minBias = 0.01f;
            const float maxBias = max(minBias,globalParam.samplingData.w);
            const float normalBias = mix(maxBias,minBias,clamp(dot(rayInfo.worldNormal,ray.direction),0.0,1.0));
            ray.origin += rayInfo.worldNormal * normalBias;

            // russian roulette
            float pathEnergy = max(max(rayThroughput.x, rayThroughput.y), rayThroughput.z);
            float energyThreshold = 1.0; 
            if (pathEnergy < energyThreshold && bounces > 4)
            {
                float q = 1.0 - pathEnergy;
                if (RandomSequenceGenerateSample1D(randSequence, sampleIndex) < q) 
                {
                    break;
                }
                rayThroughput /= (1.0 - q);
            }

            // trace again
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, ray.origin, ray.tMin, ray.direction, ray.tMax, 0);
			rayCounter++;
        }

        pixelColor += irradiance;
    }

    pixelColor = pixelColor / sampleCount;

	// gamma
	pixelColor = pow(pixelColor, vec3(1.0 / 2.2));

    // vec3 prevColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).rgb;
	// if (globalParam.moving.x < 1) 
    // {
	// 	pixelColor = prevColor * 0.5 + pixelColor * 0.5;
	// }

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(pixelColor, 0.0));
}